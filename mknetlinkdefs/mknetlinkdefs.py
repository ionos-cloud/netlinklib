"""
Build python definitions from netlink header definitions

Include build dependency on `linux-libc-dev` package

Example from https://stackoverflow.com/questions/58732872/can-python-load-definitions-from-a-c-header-file


To verify result against manually assembled defs file:
    for k, v in vars(odefs).items():
        if vars(defs).get(k) != v:
            print(k, v, vars(defs).get(k))

"""

from contextlib import ExitStack
from os import unlink
from os.path import join
from sys import stdout
from tempfile import mkstemp
from typing import ContextManager, IO, List, Literal, Tuple, Type
from typing import Literal as LiteralT
from typing import Optional as OptionalT
from types import TracebackType
from pyparsing import *
from re import match

INC = "/usr/include"

HEADERS = (
    "linux/if_link.h",
    "linux/netlink.h",
    "linux/genetlink.h",
    "linux/rtnetlink.h",
)

# tcm_block_index is the only #define that aliases the element of a struct
EXCLUDE = "(^__)|(^tcm_block_index$)"

CCODE = (
    """#include <stdio.h>
#include <linux/if_link.h>
#include <linux/netlink.h>
#include <linux/genetlink.h>
#include <linux/rtnetlink.h>

struct vn {char *n; int v;} list[] = {""",
    """\t{NULL, 0},
};

int main(int const argc, char const * const argv[])
{
\tstruct vn *cur;

\tprintf("\\"\\"\\" Autogenerated file, do not edit! \\"\\"\\"\\n\\n");
\tfor (cur = list; cur->n != NULL; cur++) {
\t\tprintf("%s = %d\\n", cur->n, cur->v);
\t}
\treturn 0;
}""",
)


class mkstemp_n:
    def __init__(self, count: int = 2) -> None:
        self.temps = tuple(mkstemp() for _ in range(count))

    def __enter__(self) -> Tuple[IO, ...]:
        files: List[IO] = []
        with ExitStack() as stk:
            for fd, _ in self.temps:
                files.append(
                    stk.enter_context(open(fd, "r+", encoding="ascii"))
                )
                self.undo = stk.pop_all()
        return tuple(files)

    def __exit__(
        self,
        ecls: OptionalT[Type[BaseException]],
        eobj: OptionalT[BaseException],
        etrc: OptionalT[TracebackType],
    ) -> LiteralT[False]:
        with self.undo:
            pass
        for _, fn in self.temps:
            try:
                unlink(fn)
            except OSError:
                pass
        return False


# syntax we don't want to see in the final parse tree
# LPAREN, RPAREN, LBRACE, RBRACE, EQ, COMMA = Suppress.using_each("(){}=,")
identifier = pyparsing_common.identifier
integer = pyparsing_common.integer
c_style_comment = Combine(Regex(r"/\*(?:[^*]|\*(?!/))*") + "*/")
LPAREN, RPAREN, LBRACE, RBRACE, EQ, COMMA = (Suppress(x) for x in "(){}=,")
_enum = Suppress("enum")
arith_op = Char("+") ^ Char("-") ^ Char("*") ^ Char("/")
arith_elem = identifier ^ integer
arith_expr = Group(arith_elem + (arith_op + arith_elem)[...])
paren_expr = arith_expr ^ (LPAREN + arith_expr + RPAREN)
enumValue = Group(
    identifier("name") + Optional(EQ + paren_expr("value"))
)
enumList = Group(enumValue + (COMMA + enumValue)[...] + Optional(COMMA))
enum = (
    _enum
    + Optional(identifier("ename"))
    + LBRACE
    + enumList("names")
    + RBRACE
)
enum.ignore(c_style_comment)

define = (
    LineStart() + Suppress("#define") + identifier("name") + White()
)
define.ignore(c_style_comment)


if __name__ == "__main__":
    names = set()
    for infn in HEADERS:
        with mkstemp_n() as (defs, rest), open(join(INC, infn)) as inp:
            line = ""
            for rline in inp.readlines():
                line += rline
                if line.endswith("\\\n"):
                    line = line.rstrip("\\\n")
                    continue
                if line.startswith("#define"):
                    defs.write(line)
                else:
                    rest.write(line)
                line = ""
            defs.seek(0)
            rest.seek(0)
            # find instances of defines ignoring other syntax
            for item, start, stop in define.scanString(defs.read()):
                if item.name:
                    if match(EXCLUDE, item.name):
                        continue
                    names.add(item.name)
                else:
                    print("****************\n", item.dump())
            # find instances of enums ignoring other syntax
            for item, start, stop in enum.scanString(rest.read()):
                idx = 0
                for entry in item.names:
                    do_print = True
                    if entry.value != "":
                        try:
                            idx = int(entry.value)
                        except TypeError:
                            do_print = False
                    if do_print and not entry.name.startswith("__"):
                        names.add(entry.name)
                    idx += 1
    with open("mkdefs.c", "w") as out:
        print(CCODE[0], file=out)
        for name in names:
            print(f'\t{{ "{name}", {name} }},', file=out)
        print(CCODE[1], file=out)
