""" Common datatypes for netlinklib moduels, including autogenerated code """

from collections import defaultdict
from struct import pack, unpack
from typing import (
    Any,
    Callable,
    ClassVar,
    Dict,
    Iterable,
    List,
    Optional,
    Sequence,
    Tuple,
    TypeVar,
    Union,
    get_type_hints,
)

from .defs import *  # pylint: disable=wildcard-import, unused-wildcard-import

__all__ = (
    "RtaDesc",
    "NllException",
    "NllError",
    "NllDumpInterrupted",
    "NllMsg",
    "StopParsing",
    "nll_assert",
    "nlmsgerr",
)

RtaDesc = Dict[int, Tuple[Callable[..., Any], Any]]


Accum = TypeVar("Accum")


class NllException(Exception):
    """Any exception originating from here"""


class NllError(NllException):
    """Error originating from here"""


class NllDumpInterrupted(NllException):
    """ "Dump interrupted" condition reported by the kernel"""


class NllMsg:
    """Encoder / decoder for a `struct` used in netlink messages"""

    __slots__: ClassVar[Tuple[str]]
    PACKFMT: ClassVar[str]
    SIZE: ClassVar[int]

    def __init__(
        self,
        *args: Any,
        **kwargs: Union[
            Any,
            Callable[[Accum, Any], Accum],
            Iterable[Callable[[Accum, Any], Accum]],
        ],
    ) -> None:
        self.callbacks: Dict[str, List[Callable[[Accum, Any], Accum]]] = (
            defaultdict(list)
        )
        try:  # Faster than checking for len(args), and this is a bottleneck
            self.from_bytes(args[0][: self.SIZE])
            self.remainder = args[0][self.SIZE :]
            return
        except IndexError:
            pass
        hints = get_type_hints(self)
        for attr in self.__slots__:
            if attr == "remainder":
                continue
            if attr in kwargs:
                val = kwargs[attr]
                if callable(val):
                    self.callbacks[attr].append(val)
                elif isinstance(val, Iterable):
                    self.callbacks[attr].extend(val)
                else:
                    # since val is loop variable, we need to make
                    # sure it gets evaluated immediately
                    self.callbacks[attr].append(
                        nll_assert(lambda x, v=val: x == v)  # type: ignore [misc]
                    )
                    setattr(self, attr, val)
            elif hints[attr] is int:
                setattr(self, attr, 0)
            else:
                raise TypeError(
                    f"Missing non-integer kwarg {attr}"
                    f" of type {hints[attr]}"
                    f" for {self.__class__.__name__},"
                )

    def __repr__(self) -> str:
        return (
            f"{self.__class__.__name__}("
            + ", ".join(
                f"{k}={repr(getattr(self, k))}"
                for k in self.__slots__
                if k != "remainder"
            )
            + ")"
        )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, NllMsg):
            return NotImplemented
        return type(self) is type(other) and self.bytes == other.bytes

    def from_bytes(
        self, inp: bytes
    ) -> None:  # pylint: disable=unused-argument
        """Parser for binary messages"""

    def parse(self, accum: Accum, data: bytes) -> Accum:
        if not self.callbacks:
            return accum
        fields: Tuple[str, ...] = self.__slots__[1:]
        for k, v in zip(fields, unpack(self.PACKFMT, data[: self.SIZE])):
            for callback in self.callbacks[k]:
                accum = callback(accum, v)  # type: ignore
        return accum

    @property
    def bytes(self) -> bytes:
        """Represent message as bytes"""
        return pack(
            self.PACKFMT,
            *tuple(
                getattr(self, x) for x in self.__slots__ if x != "remainder"
            ),
        )

    @property
    # The Union is of (int, bytes), but bytes gets incorrectly resolved
    def dict(self) -> Dict[str, Union[int, Any]]:
        return {
            k: getattr(self, k) for k in self.__slots__ if k != "remainder"
        }


# The class for struct nlmsgerr is defined by hand below. It cannot be
# autogenerated with a reasonable effort, because the struct in the
# kernel header file is defined as a _container_, with another struct
# inside. All(?) other structs are defined as _headers_ of a message,
# and consist of only scalar values, making it easy to autogenerate
# Python classes for them.
class nlmsgerr(NllMsg):
    """The _header_ of struct nlmsgerr (not the whole struct)"""

    __slots__ = ("error",)
    PACKFMT = "=i"
    SIZE = 4
    remainder: bytes
    error: int  #  i

    def from_bytes(self, inp: bytes) -> None:
        (self.error,) = unpack(self.PACKFMT, inp)


############################################################


T = TypeVar("T")


class StopParsing(Exception):
    pass


def nll_assert(stmt: Callable[[T], bool]) -> Callable[[Accum, T], Accum]:
    def _assert(accum: Accum, val: T) -> Accum:
        if not stmt(val):
            raise StopParsing
        return accum

    return _assert
